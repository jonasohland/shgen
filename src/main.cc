#include "clara.hpp"
#include "shgen.h"
#include <ctime>
#include <iomanip>

std::string ignore_unused_macro = R"(#define SHGEN_IGNORE_UNUSED(expr) do { (void)(expr); } while (0)
)";

std::string sse_includes = R"(#include <mmintrin.h>
#include <xmmintrin.h>
)";

std::string intro_comment = R"(/*
    Generated by shgen, a code-generator based on the work of Peter-Pike Sloan, with additions by Jonas Ohland.
    Find more information about the algorithm here: http://jcgt.org/published/0002/02/06/
    The shgen tool can be found here: https://github.com/jonasohland/shgen

)";

std::string into_comment_end = R"(
*/

)";

int main(int argc, const char** argv)
{
    shgen_config conf;

    auto const line_ending = [&](std::string const& leopt) {
        std::string leopt_cpy = leopt;
        std::transform(
            leopt_cpy.begin(), leopt_cpy.end(), leopt_cpy.begin(), ::tolower);

        if (leopt_cpy == "crlf")
            conf.le = "\r\n";
        else if (leopt_cpy == "lf")
            conf.le = "\n";
        else
            return clara::ParserResult::runtimeError(std::string(leopt).append(
                " could not be interpreted as a line ending. Use LF or CRLF"));

        return clara::ParserResult::ok(clara::ParseResultType::Matched);
    };

    // clang-format off
    auto cli = clara::Help(conf.printhelp) |
        clara::Opt(conf.header_only)["-H"]["--header-only"]("Output only a header file") |
        clara::Opt(conf.sse)["-s"]["--sse"]("Use SSE instructions") |
        clara::Opt(conf.condon_shortley)["-C"]["--condon-shortley"]("Include condon shortley phase thingy") |
        clara::Opt(conf.lmax, "max-L")["-L"]["--max-L"]("Maximum value for L") |
        clara::Opt(conf.lmin, "min-L")["-l"]["--min-L"]("Minimum value for L") |
        clara::Opt(conf.double_p)["-d"]["--double"]("Double precision") |
        clara::Opt(conf.single_p)["-f"]["--float"]("Single precision") |
        clara::Opt(conf.template_p)["-t"]["--template"]("Templated version") |
        clara::Opt(conf.template_loop)["-T"]["--template-loop"]("Compile time unrolled loop with templates") |
        clara::Opt(line_ending, "line-ending")["-e"]["--line-ending"]("Line endings (LF/CRLF)") |
        clara::Arg(conf.outfile, "output-file");
    // clang-format on

    auto res = cli.parse(clara::Args(argc, argv));
    
    if(conf.double_p)
        conf.single_p = false;
    
    if(conf.sse) {
        conf.single_p = true;
        conf.double_p = false;
        conf.template_p = false;
    }

    if (!res) {
        std::cerr << "Error: " << res.errorMessage() << "\n";
        return 1;
    }

    if (conf.printhelp) {
        std::cout << cli << "\n";
        return 0;
    }

    std::ostringstream stream;
    
    std::time_t now = std::time(nullptr);
    
    stream << intro_comment;
    stream << "    Generated " << std::put_time(std::gmtime(&now), "%c %Z") << " by the command: " << conf.le;
    stream << conf.indent << "shgen ";
    
    for(int i = 1; i < argc; ++i){
        if(conf.outfile == argv[i])
            continue;
        
        stream << argv[i] << " ";
    }
    
    stream << into_comment_end;
    
    if(conf.sse)
        stream << sse_includes << conf.le;
    
    if(conf.lmin < 1)
        stream << ignore_unused_macro << conf.le;

    for (int l = conf.lmin; l < conf.lmax + 1; ++l){
        build_raw_functions(conf, stream, l);
        
        if(l < conf.lmax)
            stream << conf.le;
    }


    /* std::ostringstream testout;

    testout.precision(2);

    for(int i = 0; i < 5; ++i) {

        float x[4] = { (float) i / 100, (float) i/100, (float) i/100, (float)
    i/100 }; float y[4] = {0.f, 0.f, 0.f, 0.f}; float z[4] = {0.f, 0.f, 0.f,
    0.f};

        float data[16];

        SHEval1(x, y, z, data);

        for(int k = 0; k < 16; ++k)
            testout << data[k] << " ";

        testout << "\n";
    }*/


    std::cout << stream.str();

    return 0;
}
