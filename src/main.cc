#include "clara.hpp"
#include "shgen.h"
#include <ctime>
#include <fstream>
#include <iomanip>

std::string ignore_unused_macro
    = R"(#define SHGEN_IGNORE_UNUSED(expr) do { (void)(expr); } while (0)
)";

std::string sse_includes = R"(#include <mmintrin.h>
#include <xmmintrin.h>
)";

std::string intro_comment = R"(/*
    Generated by shgen, a code-generator based on the work of Peter-Pike Sloan, with additions by Jonas Ohland.
    Find more information about the algorithm here: http://jcgt.org/published/0002/02/06/
    The shgen tool can be found here: https://github.com/jonasohland/shgen

)";

std::string into_comment_end = R"(
*/

)";

void shgen_config_resolve(shgen_config& conf)
{
    if (conf.double_p)
        conf.single_p = false;

    if (conf.sse) {
        conf.single_p   = true;
        
        if(conf.double_p)
            std::cerr << "Warning: SSE selected, ignoring double-precision option.\n";
        
        if(conf.template_p)
            std::cerr << "Warning: SSE selected, ignoring template option.\n";
        
        conf.double_p   = false;
        conf.template_p = false;
    }

    if (!conf.sourcefile.size()){
        if(!conf.header_only)
            std::cerr << "No source file given, assuming header-only.\n";
        
        conf.header_only = true;
    }

    if (conf.headerfile == "-"){
        conf.header_only = true;
    }
}

void write_file_header_comment(std::ostream& stream,
                               shgen_config& conf,
                               bool is_header,
                               int argc,
                               const char** argv)
{
    std::time_t now = std::time(nullptr);

    stream << intro_comment;
    stream << "    Generated " << std::put_time(std::gmtime(&now), "%c %Z")
           << " by the command: " << conf.le;
    stream << conf.indent << "shgen ";

    for (int i = 1; i < argc; ++i) {
        if (conf.headerfile == argv[i] or conf.sourcefile == argv[i]) continue;

        stream << argv[i] << " ";
    }

    stream << into_comment_end;

    if (conf.sse && conf.header_only) stream << sse_includes << conf.le;

    if (conf.lmin < 1 && conf.header_only) stream << ignore_unused_macro << conf.le;
}

void build_headerfile(std::ostream& stream, const shgen_config& conf)
{
    
    
    for (int l = conf.lmin; l < conf.lmax + 1; ++l) {

        if(conf.header_only)
            build_raw_functions(conf, stream, l);
        else {
            build_function_definition(conf, stream, l);
            stream << ";" << conf.le;
        }
            
        if (l < conf.lmax) stream << conf.le;
    }
}

void build_sourcefile(std::ostream& stream, shgen_config& c) {}

int main(int argc, const char** argv)
{
    shgen_config conf;

    auto const line_ending = [&](std::string const& leopt) {
        std::string leopt_cpy = leopt;
        std::transform(
            leopt_cpy.begin(), leopt_cpy.end(), leopt_cpy.begin(), ::tolower);

        if (leopt_cpy == "crlf")
            conf.le = "\r\n";
        else if (leopt_cpy == "lf")
            conf.le = "\n";
        else
            return clara::ParserResult::runtimeError(std::string(leopt).append(
                " could not be interpreted as a line ending. Use LF or CRLF"));

        return clara::ParserResult::ok(clara::ParseResultType::Matched);
    };

    // clang-format off
    auto cli = clara::Help(conf.printhelp) |
        clara::Opt(conf.header_only)["-H"]["--header-only"]("Output only a header file") |
        clara::Opt(conf.sse)["-s"]["--sse"]("Use SSE instructions") |
        clara::Opt(conf.condon_shortley)["-C"]["--condon-shortley"]("Include condon shortley phase thingy") |
        clara::Opt(conf.lmax, "max-L")["-L"]["--max-L"]("Maximum value for L") |
        clara::Opt(conf.lmin, "min-L")["-l"]["--min-L"]("Minimum value for L") |
        clara::Opt(conf.double_p)["-d"]["--double"]("Double precision") |
        clara::Opt(conf.single_p)["-f"]["--float"]("Single precision") |
        clara::Opt(conf.template_p)["-t"]["--template"]("Templated version") |
        clara::Opt(conf.template_loop)["-T"]["--template-loop"]("Compile time unrolled loop with templates") |
        clara::Opt(conf.cxx_17)["-7"]["--cxx-17"]("Enable C++17 specific stuff") |
        clara::Opt(line_ending, "line-ending")["-e"]["--line-ending"]("Line endings (LF/CRLF)") |
        clara::Arg(conf.headerfile, "header") |
        clara::Arg(conf.sourcefile, "source");
    // clang-format on

    auto res = cli.parse(clara::Args(argc, argv));

    shgen_config_resolve(conf);

    if (!res) {
        std::cerr << "Error: " << res.errorMessage() << "\n";
        return 1;
    }

    if (conf.printhelp) {
        std::cout << cli << "\n";
        return 0;
    }

    std::ostream* hfile_ptr;
    std::ostream* sfile_ptr;

    if (conf.headerfile == "-")
        hfile_ptr = &std::cout;
    else {
        hfile_ptr = new std::fstream(conf.headerfile, std::ios::out);

        if (hfile_ptr->fail()) {
            std::cerr << "Failed to open file " + conf.headerfile << "\n";
            delete hfile_ptr;
            return 1;
        }
    }
    
    if(conf.sourcefile.size()) {
        sfile_ptr = new std::fstream(conf.sourcefile, std::ios::out);
        
        if (sfile_ptr->fail()) {
            
            std::cerr << "Failed to open file " + conf.headerfile << "\n";
            
            if(hfile_ptr)
                delete hfile_ptr;
            
            delete sfile_ptr;
            return 1;
        }
    }

    write_file_header_comment(*hfile_ptr, conf, true, argc, argv);
    build_headerfile(*hfile_ptr, conf);

    if (!conf.header_only) {
        write_file_header_comment(*sfile_ptr, conf, false, argc, argv);
        build_sourcefile(*sfile_ptr, conf);
    }

    if (hfile_ptr != &std::cout) delete hfile_ptr;

    return 0;
}
