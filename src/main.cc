#include "clara.hpp"
#include "extras.h"
#include "shgen.h"
#include <ctime>
#include <fstream>
#include <iomanip>

std::string ignore_unused_macro
    = R"(#define SHGEN_IGNORE_UNUSED(expr) do { (void)(expr); } while (0)
)";

std::string sse_includes = R"(#include <mmintrin.h>
#include <xmmintrin.h>
)";

std::string intro_comment = R"(/*
    Generated by shgen, a code-generator based on the work of Peter-Pike Sloan, with additions by Jonas Ohland.
    Find more information about the algorithm here: http://jcgt.org/published/0002/02/06/
    The shgen tool can be found here: https://github.com/jonasohland/shgen

)";

std::string into_comment_end = R"(
*/

)";

std::string basepath(const std::string& path)
{
    auto tkit = path.find_last_of("/");

    if (tkit == std::string::npos) return "";

    return path.substr(0, tkit);
}

std::string filecmpnt(const std::string& path)
{
    auto tkit = path.find_last_of("/");

    if (tkit == std::string::npos) return path;

    return path.substr(tkit + 1, path.size() - 1);
}

void shgen_config_resolve(shgen_config& conf)
{
    if (conf.double_p) conf.single_p = false;

    if (conf.sse) {
        conf.single_p = true;

        if (conf.double_p)
            std::cerr
                << "Warning: SSE selected, ignoring double-precision option.\n";

        if (conf.template_p)
            std::cerr << "Warning: SSE selected, ignoring template option.\n";

        conf.double_p   = false;
        conf.template_p = false;
    }

    if (!conf.sourcefile.size()) {
        if (!conf.header_only)
            std::cerr << "No source file given, assuming header-only.\n";

        conf.header_only = true;
    }

    if (conf.headerfile == "-") { conf.header_only = true; }

    if (conf.c) {
        if (conf.template_p) {
            std::cerr << "C-mode selected, ignoring template option.\n";
            conf.template_p = false;
        }
        
        if (conf.cxx_17) {
            std::cerr << "C-mode selected, ignoring cxx_17 option.\n";
            conf.cxx_17 = false;
        }

        conf.nmspace          = "";
        conf.detail_nmspace   = "";
        conf.indent_fnbody    = "    ";
        conf.indent_namespace = "";
    }

    if (conf.template_p) conf.header_only = true;
}

void write_file_header_comment(std::ostream& stream,
                               shgen_config& conf,
                               bool is_header,
                               int argc,
                               const char** argv)
{
    std::time_t now = std::time(nullptr);

    stream << intro_comment;
    stream << "    Generated " << std::put_time(std::gmtime(&now), "%c %Z")
           << " by the command: " << conf.le;
    stream << conf.indent_fnbody << "shgen ";

    for (int i = 1; i < argc; ++i) {
        if (conf.headerfile == argv[i] || conf.sourcefile == argv[i]) continue;

        stream << argv[i] << " ";
    }

    stream << into_comment_end;

    if (is_header) stream << "#pragma once" << conf.le << conf.le;

    if (conf.sse && conf.header_only) stream << sse_includes << conf.le;

    if (conf.lmin < 1 && (conf.header_only || !is_header))
        stream << ignore_unused_macro << conf.le;
}

void build_headerfile(std::ostream& stream, shgen_config& conf)
{
    int namespace_lvls = 0;

    if (conf.nmspace.size()) {
        ++namespace_lvls;

        conf.indent_namespace = conf.indent_namespace.append("    ");
        conf.indent_fnbody    = conf.indent_fnbody.append("    ");

        stream << "namespace " << conf.nmspace << " { " << conf.le;

        if (conf.detail_nmspace.size()) {
            ++namespace_lvls;
            stream << conf.indent_namespace << "namespace "
                   << conf.detail_nmspace << " {";
            conf.indent_namespace = conf.indent_namespace.append("    ");
            conf.indent_fnbody    = conf.indent_fnbody.append("    ");
        }

        stream << conf.le << conf.le;
    }

    for (int l = conf.lmin; l < conf.lmax + 1; ++l) {

        if (conf.header_only)
            build_raw_functions(conf, stream, l, false);
        else {
            build_function_definition(conf, stream, l, false);
            stream << ";" << conf.le;
        }

        if (l < conf.lmax) stream << conf.le;
    }

    if (namespace_lvls > 1) {
        conf.indent_fnbody
            = conf.indent_fnbody.substr(0, conf.indent_fnbody.size() - 4);
        conf.indent_namespace
            = conf.indent_namespace.substr(0, conf.indent_namespace.size() - 4);
        --namespace_lvls;
        stream << conf.indent_namespace << "}" << conf.le;
    }

    add_extras(conf, stream, true);

    for (int i = 0; i < namespace_lvls; ++i) {
        conf.indent_fnbody
            = conf.indent_fnbody.substr(0, conf.indent_fnbody.size() - 4);
        conf.indent_namespace
            = conf.indent_namespace.substr(0, conf.indent_namespace.size() - 4);

        stream << conf.indent_namespace << "}" << conf.le;
    }

    if (namespace_lvls) stream << conf.le;
}

void build_sourcefile(std::ostream& stream, shgen_config& c)
{
    auto hfilename = filecmpnt(c.headerfile);

    stream << "#include ";

    // use system include style (#include <thing.h> not #include "thing.h")
    if (basepath(c.headerfile) != basepath(c.sourcefile))
        stream << "<" << hfilename << ">";
    else
        stream << "\"" << hfilename << "\"";

    if (c.sse) stream << c.le << sse_includes;

    stream << c.le << c.le;

    for (int l = c.lmin; l < c.lmax + 1; ++l) {
        build_raw_functions(c, stream, l, true);
        if (l < c.lmax) stream << c.le;
    }

    add_extras(c, stream, false);
}

int main(int argc, const char** argv)
{
    shgen_config conf;

    auto const line_ending = [&](std::string const& leopt) {
        std::string leopt_cpy = leopt;
        std::transform(
            leopt_cpy.begin(), leopt_cpy.end(), leopt_cpy.begin(), ::tolower);

        if (leopt_cpy == "crlf")
            conf.le = "\r\n";
        else if (leopt_cpy == "lf")
            conf.le = "\n";
        else
            return clara::ParserResult::runtimeError(std::string(leopt).append(
                " could not be interpreted as a line ending. Use LF or CRLF"));

        return clara::ParserResult::ok(clara::ParseResultType::Matched);
    };

    // clang-format off
    auto cli = clara::Help(conf.printhelp) |
        clara::Opt(conf.printver)["-v"]["--version"]("Print version and exit") |
        clara::Opt(conf.header_only)["-H"]["--header-only"]("Output only a header file") |
        clara::Opt(conf.sse)["-s"]["--sse"]("Use SSE instructions") |
        clara::Opt(conf.condon_shortley)["-C"]["--condon-shortley"]("Include condon shortley phase thingy") |
        clara::Opt(conf.lmax, "max-L")["-L"]["--max-L"]("Maximum value for L") |
        clara::Opt(conf.lmin, "min-L")["-l"]["--min-L"]("Minimum value for L") |
        clara::Opt(conf.double_p)["-d"]["--double"]("Double precision") |
        clara::Opt(conf.single_p)["-f"]["--float"]("Single precision") |
        clara::Opt(conf.template_p)["-t"]["--template"]("Templated version") |
        clara::Opt(conf.c)["-c"]["--c-mode"]("Emit plain and simple c, without all the template stuff") |
        clara::Opt(conf.cxx_17)["-7"]["--cxx-17"]("Enable C++17 specific stuff") |
        clara::Opt(line_ending, "line-ending")["-e"]["--line-ending"]("Line endings (LF/CRLF)") |
        clara::Arg(conf.headerfile, "header") |
        clara::Arg(conf.sourcefile, "source");
    // clang-format on

    auto res = cli.parse(clara::Args(argc, argv));
    
    if (!res) {
        std::cerr << "Error: " << res.errorMessage() << "\n";
        return 1;
    }

    if (conf.printhelp) {
        std::cout << cli << "\n";
        return 0;
    }
    
    if(conf.printver) {
#define SHGEN_STR_IMPL(x) #x
#define SHGEN_STR(x) SHGEN_STR_IMPL(x)
        std::cout << "shgen-" << SHGEN_STR(SHGEN_VERSION) << "\n";
        return 0;
    }

    shgen_config_resolve(conf);

    std::ostream* hfile_ptr = nullptr;
    std::ostream* sfile_ptr = nullptr;

    if (conf.headerfile == "-")
        hfile_ptr = &std::cout;
    else {
        hfile_ptr = new std::fstream(conf.headerfile, std::ios::out);

        if (hfile_ptr->fail()) {
            std::cerr << "Failed to open file " + conf.headerfile << "\n";
            delete hfile_ptr;
            return 1;
        }
    }

    if (conf.sourcefile.size()) {
        sfile_ptr = new std::fstream(conf.sourcefile, std::ios::out);
        if (sfile_ptr->fail()) {
            std::cerr << "Failed to open file " + conf.headerfile << "\n";

            if (hfile_ptr) delete hfile_ptr;

            delete sfile_ptr;
            return 1;
        }
    }

    write_file_header_comment(*hfile_ptr, conf, true, argc, argv);
    build_headerfile(*hfile_ptr, conf);

    if (!conf.header_only) {
        write_file_header_comment(*sfile_ptr, conf, false, argc, argv);
        build_sourcefile(*sfile_ptr, conf);
    }

    if (hfile_ptr != &std::cout) delete hfile_ptr;
    if (sfile_ptr) delete sfile_ptr;

    return 0;
}
